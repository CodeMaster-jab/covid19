'use strict';
<<<<<<< HEAD
const fs = require('fs');
=======
>>>>>>> 37d774246a886414ad3dcaef6f0d5ef6c08bf9d8
const arrayUnion = require('array-union');
const glob = require('glob');
const fastGlob = require('fast-glob');
const dirGlob = require('dir-glob');
const gitignore = require('./gitignore');

const DEFAULT_FILTER = () => false;

const isNegative = pattern => pattern[0] === '!';

const assertPatternsInput = patterns => {
	if (!patterns.every(x => typeof x === 'string')) {
		throw new TypeError('Patterns must be a string or an array of strings');
	}
};

<<<<<<< HEAD
const checkCwdOption = options => {
	if (options && options.cwd && !fs.statSync(options.cwd).isDirectory()) {
		throw new Error('The `cwd` option must be a path to a directory');
	}
};

const generateGlobTasks = (patterns, taskOptions) => {
	patterns = arrayUnion([].concat(patterns));
	assertPatternsInput(patterns);
	checkCwdOption(taskOptions);

	const globTasks = [];

	taskOptions = Object.assign({
		ignore: [],
		expandDirectories: true
	}, taskOptions);
=======
const generateGlobTasks = (patterns, taskOpts) => {
	patterns = [].concat(patterns);
	assertPatternsInput(patterns);

	const globTasks = [];

	taskOpts = Object.assign({
		ignore: [],
		expandDirectories: true
	}, taskOpts);
>>>>>>> 37d774246a886414ad3dcaef6f0d5ef6c08bf9d8

	patterns.forEach((pattern, i) => {
		if (isNegative(pattern)) {
			return;
		}

		const ignore = patterns
			.slice(i)
			.filter(isNegative)
			.map(pattern => pattern.slice(1));

<<<<<<< HEAD
		const options = Object.assign({}, taskOptions, {
			ignore: taskOptions.ignore.concat(ignore)
		});

		globTasks.push({pattern, options});
=======
		const opts = Object.assign({}, taskOpts, {
			ignore: taskOpts.ignore.concat(ignore)
		});

		globTasks.push({pattern, opts});
>>>>>>> 37d774246a886414ad3dcaef6f0d5ef6c08bf9d8
	});

	return globTasks;
};

const globDirs = (task, fn) => {
<<<<<<< HEAD
	let options = {};
	if (task.options.cwd) {
		options.cwd = task.options.cwd;
	}

	if (Array.isArray(task.options.expandDirectories)) {
		options = Object.assign(options, {files: task.options.expandDirectories});
	} else if (typeof task.options.expandDirectories === 'object') {
		options = Object.assign(options, task.options.expandDirectories);
	}

	return fn(task.pattern, options);
};

const getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];

const globToTask = task => glob => {
	const {options} = task;
	if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
		options.ignore = dirGlob.sync(options.ignore);
	}

	return {
		pattern: glob,
		options
	};
};

const globby = (patterns, options) => {
	let globTasks;

	try {
		globTasks = generateGlobTasks(patterns, options);
	} catch (error) {
		return Promise.reject(error);
	}

	const getTasks = Promise.all(globTasks.map(task => Promise.resolve(getPattern(task, dirGlob))
		.then(globs => Promise.all(globs.map(globToTask(task))))
	))
		.then(tasks => arrayUnion(...tasks));

	const getFilter = () => {
		return Promise.resolve(
			options && options.gitignore ?
				gitignore({cwd: options.cwd, ignore: options.ignore}) :
=======
	let opts = {cwd: task.opts.cwd};

	if (Array.isArray(task.opts.expandDirectories)) {
		opts = Object.assign(opts, {files: task.opts.expandDirectories});
	} else if (typeof task.opts.expandDirectories === 'object') {
		opts = Object.assign(opts, task.opts.expandDirectories);
	}

	return fn(task.pattern, opts);
};

const getPattern = (task, fn) => task.opts.expandDirectories ? globDirs(task, fn) : [task.pattern];

module.exports = (patterns, opts) => {
	let globTasks;

	try {
		globTasks = generateGlobTasks(patterns, opts);
	} catch (err) {
		return Promise.reject(err);
	}

	const getTasks = Promise.all(globTasks.map(task => Promise.resolve(getPattern(task, dirGlob))
		.then(globs => Promise.all(globs.map(glob => ({
			pattern: glob,
			opts: task.opts
		}))))
	))
		.then(tasks => arrayUnion.apply(null, tasks));

	const getFilter = () => {
		return Promise.resolve(
			opts && opts.gitignore ?
				gitignore({cwd: opts.cwd, ignore: opts.ignore}) :
>>>>>>> 37d774246a886414ad3dcaef6f0d5ef6c08bf9d8
				DEFAULT_FILTER
		);
	};

	return getFilter()
		.then(filter => {
			return getTasks
<<<<<<< HEAD
				.then(tasks => Promise.all(tasks.map(task => fastGlob(task.pattern, task.options))))
				.then(paths => arrayUnion(...paths))
=======
				.then(tasks => Promise.all(tasks.map(task => fastGlob(task.pattern, task.opts))))
				.then(paths => arrayUnion.apply(null, paths))
>>>>>>> 37d774246a886414ad3dcaef6f0d5ef6c08bf9d8
				.then(paths => paths.filter(p => !filter(p)));
		});
};

<<<<<<< HEAD
module.exports = globby;
// TODO: Remove this for the next major release
module.exports.default = globby;

module.exports.sync = (patterns, options) => {
	const globTasks = generateGlobTasks(patterns, options);

	const getFilter = () => {
		return options && options.gitignore ?
			gitignore.sync({cwd: options.cwd, ignore: options.ignore}) :
=======
module.exports.sync = (patterns, opts) => {
	const globTasks = generateGlobTasks(patterns, opts);

	const getFilter = () => {
		return opts && opts.gitignore ?
			gitignore.sync({cwd: opts.cwd, ignore: opts.ignore}) :
>>>>>>> 37d774246a886414ad3dcaef6f0d5ef6c08bf9d8
			DEFAULT_FILTER;
	};

	const tasks = globTasks.reduce((tasks, task) => {
<<<<<<< HEAD
		const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
=======
		const newTask = getPattern(task, dirGlob.sync).map(glob => ({
			pattern: glob,
			opts: task.opts
		}));
>>>>>>> 37d774246a886414ad3dcaef6f0d5ef6c08bf9d8
		return tasks.concat(newTask);
	}, []);

	const filter = getFilter();
<<<<<<< HEAD
	return tasks.reduce(
		(matches, task) => arrayUnion(matches, fastGlob.sync(task.pattern, task.options)),
=======

	return tasks.reduce(
		(matches, task) => arrayUnion(matches, fastGlob.sync(task.pattern, task.opts)),
>>>>>>> 37d774246a886414ad3dcaef6f0d5ef6c08bf9d8
		[]
	).filter(p => !filter(p));
};

module.exports.generateGlobTasks = generateGlobTasks;

<<<<<<< HEAD
module.exports.hasMagic = (patterns, options) => []
	.concat(patterns)
	.some(pattern => glob.hasMagic(pattern, options));
=======
module.exports.hasMagic = (patterns, opts) => []
	.concat(patterns)
	.some(pattern => glob.hasMagic(pattern, opts));
>>>>>>> 37d774246a886414ad3dcaef6f0d5ef6c08bf9d8

module.exports.gitignore = gitignore;
